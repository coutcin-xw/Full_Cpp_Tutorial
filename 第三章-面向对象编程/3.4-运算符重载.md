# 3.4 运算符重载

## 目录
- [重载的基本规则](#重载的基本规则)
- [常用运算符重载](#常用运算符重载)
- [输入输出运算符重载](#输入输出运算符重载)
- [函数调用运算符重载](#函数调用运算符重载)
- [下标运算符重载](#下标运算符重载)
- [比较运算符重载](#比较运算符重载)

---

## 重载的基本规则

### 可以重载的运算符

```cpp
// ✅ 可以重载的运算符
+    -    *    /    %    ^    &    |    ~
!    =    <    >    +=   -=   *=   /=   %=
^=   &=   |=   <<   >>   >>=  <<=  ==   !=
<=   >=   &&   ||   ++   --   ,    ->*  ->
( )  [ ]  new  delete new[] delete[]
```

### 不能重载的运算符

```cpp
// ❌ 不能重载的运算符
::           // 作用域解析
.            // 成员访问
.*           // 成员指针访问
?:           // 三目运算符
sizeof       // 大小运算符
typeid       // 类型识别
alignof      // 对齐要求(C++11)
noexcept     // 异常说明(C++11)
```

### 重载的基本语法

```cpp
#include <iostream>

class Complex {
private:
    double real;
    double imag;

public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}

    // 成员函数重载：双目运算符
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }

    // 成员函数重载：单目运算符
    Complex operator-() const {
        return Complex(-real, -imag);
    }

    void display() const {
        std::cout << real << " + " << imag << "i\n";
    }
};

int main() {
    Complex c1(3.0, 4.0);
    Complex c2(1.0, 2.0);

    Complex c3 = c1 + c2;  // 等价于 c1.operator+(c2)
    c3.display();

    Complex c4 = -c1;      // 等价于 c1.operator-()
    c4.display();

    return 0;
}
```

### 重载规则

```cpp
#include <iostream>

class Number {
private:
    int value;

public:
    Number(int v = 0) : value(v) {}

    // 1. 不能改变运算符的优先级
    Number operator+(const Number& other) const {
        return Number(value + other.value);  // 仍然是先乘除后加减
    }

    // 2. 不能改变运算符的结合性
    Number operator-(const Number& other) const {
        return Number(value - other.value);  // 仍然是从左到右
    }

    // 3. 不能改变运算符的操作数个数
    // Number operator+(const Number& a, const Number& b, const Number& c);  // ❌ 错误

    // 4. 至少有一个操作数必须是用户定义类型
    // int operator+(int, int);  // ❌ 不能重载内置类型的运算符

    // 5. 默认参数不能用于重载运算符
    // Number operator+(const Number& other = Number()) const;  // ❌ 错误

    void display() const {
        std::cout << "value = " << value << "\n";
    }
};
```

### 成员函数 vs 非成员函数

```cpp
#include <iostream>

class Complex {
private:
    double real;
    double imag;

public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}

    // 成员函数：this作为左操作数
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }

    void display() const {
        std::cout << real << " + " << imag << "i\n";
    }

    // 友元函数：可以访问私有成员
    friend Complex operator+(double d, const Complex& c);
};

// 非成员函数：实现 double + Complex
Complex operator+(double d, const Complex& c) {
    return Complex(d + c.real, c.imag);
}

int main() {
    Complex c1(3.0, 4.0);
    Complex c2(1.0, 2.0);

    // 成员函数：对象 + 对象
    Complex c3 = c1 + c2;
    c3.display();

    // 成员函数：对象 + double
    Complex c4 = c1 + 2.5;
    c4.display();

    // 非成员函数：double + 对象
    Complex c5 = 2.5 + c1;
    c5.display();

    return 0;
}
```

**选择指南：**

| 运算符 | 推荐方式 | 原因 |
|--------|----------|------|
| `=`, `[]`, `()`, `->`, `->*` | 成员函数 | 必须是成员 |
| 复合赋值(`+=`, `-=`等) | 成员函数 | 修改左操作数 |
| 单目运算符(`++`, `--`, `!`等) | 成员函数 | 操作一个对象 |
| 双目运算符(`+`, `-`, `*`, `/`等) | 非成员函数 | 支持类型转换 |
| 输入输出(`<<`, `>>`) | 非成员函数 | 左操作数是流 |

---

## 常用运算符重载

### 算术运算符

```cpp
#include <iostream>

class Vector2D {
private:
    double x, y;

public:
    Vector2D(double x = 0, double y = 0) : x(x), y(y) {}

    // 加法
    Vector2D operator+(const Vector2D& other) const {
        return Vector2D(x + other.x, y + other.y);
    }

    // 减法
    Vector2D operator-(const Vector2D& other) const {
        return Vector2D(x - other.x, y - other.y);
    }

    // 标量乘法
    Vector2D operator*(double scalar) const {
        return Vector2D(x * scalar, y * scalar);
    }

    // 点积
    double dot(const Vector2D& other) const {
        return x * other.x + y * other.y;
    }

    void display() const {
        std::cout << "(" << x << ", " << y << ")\n";
    }
};

int main() {
    Vector2D v1(3.0, 4.0);
    Vector2D v2(1.0, 2.0);

    Vector2D v3 = v1 + v2;
    v3.display();  // (4, 6)

    Vector2D v4 = v1 - v2;
    v4.display();  // (2, 2)

    Vector2D v5 = v1 * 2.0;
    v5.display();  // (6, 8)

    double dotProduct = v1.dot(v2);
    std::cout << "点积: " << dotProduct << "\n";  // 11

    return 0;
}
```

### 自增自减运算符

```cpp
#include <iostream>

class Counter {
private:
    int count;

public:
    Counter(int c = 0) : count(c) {}

    // 前置++：++counter
    Counter& operator++() {
        ++count;
        return *this;  // 返回修改后的对象
    }

    // 后置++：counter++
    Counter operator++(int) {  // int参数是哑元，区分前置和后置
        Counter temp = *this;  // 保存原值
        ++count;
        return temp;  // 返回原值
    }

    // 前置--
    Counter& operator--() {
        --count;
        return *this;
    }

    // 后置--
    Counter operator--(int) {
        Counter temp = *this;
        --count;
        return temp;
    }

    void display() const {
        std::cout << "count = " << count << "\n";
    }
};

int main() {
    Counter c(10);

    c.display();  // 10

    Counter c1 = ++c;  // 前置：先增后返回
    c.display();       // 11
    c1.display();      // 11

    Counter c2 = c++;  // 后置：先返回后增
    c.display();       // 12
    c2.display();      // 11

    return 0;
}
```

### 赋值运算符

```cpp
#include <iostream>
#include <cstring>

class MyString {
private:
    char* data;

public:
    MyString(const char* str = "") {
        if (str) {
            data = new char[strlen(str) + 1];
            strcpy(data, str);
        } else {
            data = new char[1];
            data[0] = '\0';
        }
    }

    // 拷贝构造函数
    MyString(const MyString& other) {
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
    }

    // 拷贝赋值运算符
    MyString& operator=(const MyString& other) {
        if (this != &other) {  // 防止自赋值
            delete[] data;  // 释放旧内存
            data = new char[strlen(other.data) + 1];
            strcpy(data, other.data);
        }
        return *this;  // 支持链式赋值
    }

    // 移动赋值运算符（C++11）
    MyString& operator=(MyString&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }

    ~MyString() {
        delete[] data;
    }

    void display() const {
        if (data) {
            std::cout << data << "\n";
        }
    }
};

int main() {
    MyString s1("Hello");
    MyString s2("World");

    s1 = s2;  // 调用拷贝赋值
    s1.display();

    s1 = MyString("C++");  // 调用移动赋值
    s1.display();

    // 链式赋值
    MyString s3, s4, s5;
    s3 = s4 = s5 = "Chain";
    s3.display();

    return 0;
}
```

### 复合赋值运算符

```cpp
#include <iostream>

class Money {
private:
    double amount;

public:
    Money(double a = 0.0) : amount(a) {}

    // +=
    Money& operator+=(const Money& other) {
        amount += other.amount;
        return *this;  // 返回引用
    }

    // -=
    Money& operator-=(const Money& other) {
        amount -= other.amount;
        return *this;
    }

    // *=
    Money& operator*=(double rate) {
        amount *= rate;
        return *this;
    }

    void display() const {
        std::cout << "¥" << amount << "\n";
    }
};

int main() {
    Money m1(100.0);
    Money m2(50.0);

    m1 += m2;
    m1.display();  // ¥150

    m1 -= Money(30.0);
    m1.display();  // ¥120

    m1 *= 1.1;  // 增加10%
    m1.display();  // ¥132

    return 0;
}
```

---

## 输入输出运算符重载

### 重载输出运算符 <<

```cpp
#include <iostream>
#include <string>

class Point {
private:
    int x, y;

public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    // 友元函数：重载 <<
    friend std::ostream& operator<<(std::ostream& os, const Point& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;  // 支持链式输出
    }
};

int main() {
    Point p1(3, 4);
    Point p2(10, 20);

    std::cout << "p1 = " << p1 << "\n";
    std::cout << "p2 = " << p2 << "\n";

    // 链式输出
    std::cout << p1 << " 和 " << p2 << "\n";

    return 0;
}
```

### 重载输入运算符 >>

```cpp
#include <iostream>
#include <string>

class Student {
private:
    std::string name;
    int age;

public:
    Student() : name(""), age(0) {}

    friend std::ostream& operator<<(std::ostream& os, const Student& s) {
        os << s.name << " (" << s.age << "岁)";
        return os;
    }

    friend std::istream& operator>>(std::istream& is, Student& s) {
        std::cout << "请输入姓名: ";
        is >> s.name;
        std::cout << "请输入年龄: ";
        is >> s.age;
        return is;
    }
};

int main() {
    Student s1;

    std::cin >> s1;  // 输入数据
    std::cout << "学生信息: " << s1 << "\n";

    return 0;
}
```

### 输入输出的完整示例

```cpp
#include <iostream>
#include <iomanip>

class Date {
private:
    int year, month, day;

public:
    Date(int y = 0, int m = 0, int d = 0) : year(y), month(m), day(d) {}

    friend std::ostream& operator<<(std::ostream& os, const Date& date) {
        os << std::setfill('0');
        os << std::setw(4) << date.year << "-"
           << std::setw(2) << date.month << "-"
           << std::setw(2) << date.day;
        return os;
    }

    friend std::istream& operator>>(std::istream& is, Date& date) {
        char sep1, sep2;
        is >> date.year >> sep1 >> date.month >> sep2 >> date.day;

        // 简单验证
        if (sep1 != '-' || sep2 != '-') {
            is.setstate(std::ios::failbit);
        }

        return is;
    }

    bool isValid() const {
        if (year < 1 || month < 1 || month > 12 || day < 1) {
            return false;
        }
        // 可以添加更多验证...
        return true;
    }
};

int main() {
    Date today(2024, 1, 15);
    std::cout << "今天是: " << today << "\n";

    std::cout << "请输入日期(YYYY-MM-DD): ";
    Date input;
    std::cin >> input;

    if (std::cin && input.isValid()) {
        std::cout << "你输入的日期: " << input << "\n";
    } else {
        std::cout << "日期格式无效\n";
    }

    return 0;
}
```

---

## 函数调用运算符重载

### 函数对象（Functor）

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

class Multiply {
private:
    int factor;

public:
    Multiply(int f) : factor(f) {}

    // 重载函数调用运算符
    int operator()(int x) const {
        return x * factor;
    }
};

int main() {
    Multiply times3(3);
    Multiply times5(5);

    std::cout << "3 * 7 = " << times3(7) << "\n";
    std::cout << "5 * 7 = " << times5(7) << "\n";

    // 与STL算法结合使用
    std::vector<int> vec = {1, 2, 3, 4, 5};

    std::cout << "每个元素乘3:\n";
    for (int num : vec) {
        std::cout << times3(num) << " ";
    }
    std::cout << "\n";

    return 0;
}
```

### 带状态的函数对象

```cpp
#include <iostream>

class Counter {
private:
    int count;
    int step;

public:
    Counter(int c = 0, int s = 1) : count(c), step(s) {}

    int operator()() {
        count += step;
        return count;
    }

    void reset() {
        count = 0;
    }
};

int main() {
    Counter counter(0, 2);  // 从0开始，每次加2

    std::cout << counter() << "\n";  // 2
    std::cout << counter() << "\n";  // 4
    std::cout << counter() << "\n";  // 6

    counter.reset();
    std::cout << "重置后: " << counter() << "\n";  // 2

    return 0;
}
```

### lambda vs 函数对象

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 函数对象
class IsGreaterThan {
private:
    int threshold;

public:
    IsGreaterThan(int t) : threshold(t) {}

    bool operator()(int value) const {
        return value > threshold;
    }
};

int main() {
    std::vector<int> numbers = {1, 5, 10, 15, 20, 25};

    // 使用函数对象
    IsGreaterThan greaterThan10(10);
    auto it1 = std::find_if(numbers.begin(), numbers.end(), greaterThan10);
    if (it1 != numbers.end()) {
        std::cout << "第一个大于10的数: " << *it1 << "\n";
    }

    // 使用lambda（C++11）
    auto it2 = std::find_if(numbers.begin(), numbers.end(),
                           [](int n) { return n > 10; });
    if (it2 != numbers.end()) {
        std::cout << "第一个大于10的数: " << *it2 << "\n";
    }

    return 0;
}
```

---

## 下标运算符重载

### 基本下标运算符

```cpp
#include <iostream>
#include <stdexcept>

class Array {
private:
    int* data;
    size_t size;

public:
    Array(size_t s) : size(s) {
        data = new int[size];
    }

    ~Array() {
        delete[] data;
    }

    // 非const版本
    int& operator[](size_t index) {
        if (index >= size) {
            throw std::out_of_range("索引越界");
        }
        return data[index];
    }

    // const版本
    const int& operator[](size_t index) const {
        if (index >= size) {
            throw std::out_of_range("索引越界");
        }
        return data[index];
    }

    size_t getSize() const { return size; }
};

int main() {
    Array arr(5);

    // 写入
    for (size_t i = 0; i < arr.getSize(); i++) {
        arr[i] = static_cast<int>(i * 10);
    }

    // 读取
    for (size_t i = 0; i < arr.getSize(); i++) {
        std::cout << "arr[" << i << "] = " << arr[i] << "\n";
    }

    // const对象
    const Array& carr = arr;
    std::cout << "carr[2] = " << carr[2] << "\n";

    return 0;
}
```

### 二维数组下标

```cpp
#include <iostream>
#include <vector>

class Matrix {
private:
    std::vector<std::vector<int>> data;

public:
    Matrix(size_t rows, size_t cols) : data(rows, std::vector<int>(cols)) {}

    // 返回行，然后再次应用[]
    std::vector<int>& operator[](size_t row) {
        return data[row];
    }

    const std::vector<int>& operator[](size_t row) const {
        return data[row];
    }

    void display() const {
        for (const auto& row : data) {
            for (int val : row) {
                std::cout << val << " ";
            }
            std::cout << "\n";
        }
    }
};

int main() {
    Matrix mat(3, 3);

    // 填充数据
    int count = 1;
    for (size_t i = 0; i < 3; i++) {
        for (size_t j = 0; j < 3; j++) {
            mat[i][j] = count++;
        }
    }

    mat.display();

    // 访问元素
    std::cout << "mat[1][1] = " << mat[1][1] << "\n";

    return 0;
}
```

---

## 比较运算符重载

### 基本比较运算符

```cpp
#include <iostream>
#include <string>

class Student {
private:
    std::string name;
    int score;

public:
    Student(const std::string& n, int s) : name(n), score(s) {}

    // ==
    bool operator==(const Student& other) const {
        return score == other.score;
    }

    // !=
    bool operator!=(const Student& other) const {
        return score != other.score;
    }

    // <
    bool operator<(const Student& other) const {
        return score < other.score;
    }

    // >
    bool operator>(const Student& other) const {
        return score > other.score;
    }

    // <=
    bool operator<=(const Student& other) const {
        return score <= other.score;
    }

    // >=
    bool operator>=(const Student& other) const {
        return score >= other.score;
    }

    void display() const {
        std::cout << name << ": " << score << "分\n";
    }
};

int main() {
    Student s1("张三", 85);
    Student s2("李四", 92);
    Student s3("王五", 85);

    std::cout << std::boolalpha;
    std::cout << "s1 == s3: " << (s1 == s3) << "\n";  // true
    std::cout << "s1 < s2: " << (s1 < s2) << "\n";    // true
    std::cout << "s1 > s3: " << (s1 > s3) << "\n";    // false

    return 0;
}
```

### 使用 std::rel_ops

```cpp
#include <iostream>
#include <utility>
#include <string>

class Point {
private:
    int x, y;

public:
    Point(int x, int y) : x(x), y(y) {}

    // 只需实现 == 和 <
    bool operator==(const Point& other) const {
        return x == other.x && y == other.y;
    }

    bool operator<(const Point& other) const {
        if (x != other.x) {
            return x < other.x;
        }
        return y < other.y;
    }

    void display() const {
        std::cout << "(" << x << ", " << y << ")\n";
    }
};

int main() {
    using namespace std::rel_ops;  // 引入其他比较运算符

    Point p1(1, 2);
    Point p2(1, 3);
    Point p3(1, 2);

    std::cout << std::boolalpha;
    std::cout << "p1 == p3: " << (p1 == p3) << "\n";
    std::cout << "p1 != p2: " << (p1 != p2) << "\n";  // 自动生成
    std::cout << "p1 <= p2: " << (p1 <= p2) << "\n";  // 自动生成
    std::cout << "p1 > p3: " << (p1 > p3) << "\n";    // 自动生成

    return 0;
}
```

---

## 运算符重载综合示例

### 示例：有理数类

```cpp
#include <iostream>
#include <stdexcept>
#include <numeric>

class Rational {
private:
    int numerator;   // 分子
    int denominator; // 分母

    // 化简分数
    void simplify() {
        if (denominator < 0) {
            numerator = -numerator;
            denominator = -denominator;
        }

        int gcd = std::gcd(std::abs(numerator), std::abs(denominator));
        numerator /= gcd;
        denominator /= gcd;
    }

public:
    Rational(int n = 0, int d = 1) : numerator(n), denominator(d) {
        if (denominator == 0) {
            throw std::invalid_argument("分母不能为0");
        }
        simplify();
    }

    // 算术运算符
    Rational operator+(const Rational& other) const {
        int num = numerator * other.denominator + other.numerator * denominator;
        int den = denominator * other.denominator;
        return Rational(num, den);
    }

    Rational operator-(const Rational& other) const {
        int num = numerator * other.denominator - other.numerator * denominator;
        int den = denominator * other.denominator;
        return Rational(num, den);
    }

    Rational operator*(const Rational& other) const {
        return Rational(numerator * other.numerator,
                       denominator * other.denominator);
    }

    Rational operator/(const Rational& other) const {
        return Rational(numerator * other.denominator,
                       denominator * other.numerator);
    }

    // 比较运算符
    bool operator==(const Rational& other) const {
        return numerator == other.numerator &&
               denominator == other.denominator;
    }

    bool operator<(const Rational& other) const {
        return numerator * other.denominator <
               other.numerator * denominator;
    }

    // 输入输出运算符
    friend std::ostream& operator<<(std::ostream& os, const Rational& r) {
        os << r.numerator;
        if (r.denominator != 1) {
            os << "/" << r.denominator;
        }
        return os;
    }

    friend std::istream& operator>>(std::istream& is, Rational& r) {
        is >> r.numerator;
        char sep;
        is >> sep;
        if (sep == '/') {
            is >> r.denominator;
        } else {
            is.putback(sep);
            r.denominator = 1;
        }
        r.simplify();
        return is;
    }

    // 转换为double
    double toDouble() const {
        return static_cast<double>(numerator) / denominator;
    }
};

int main() {
    Rational r1(1, 2);
    Rational r2(1, 3);

    std::cout << "r1 = " << r1 << "\n";
    std::cout << "r2 = " << r2 << "\n";

    std::cout << "r1 + r2 = " << r1 + r2 << "\n";
    std::cout << "r1 - r2 = " << r1 - r2 << "\n";
    std::cout << "r1 * r2 = " << r1 * r2 << "\n";
    std::cout << "r1 / r2 = " << r1 / r2 << "\n";

    std::cout << "r1 < r2: " << (r1 < r2) << "\n";
    std::cout << "r1 == r2: " << (r1 == r2) << "\n";

    return 0;
}
```

---

## 小结

本节介绍了C++的运算符重载：

1. **重载的基本规则**：
   - 可以重载和不能重载的运算符
   - 成员函数 vs 非成员函数
   - 保持运算符的原有语义

2. **常用运算符重载**：
   - 算术运算符
   - 自增自减
   - 赋值运算符
   - 复合赋值

3. **输入输出运算符**：
   - `<<`和`>>`通常重载为友元函数
   - 返回流引用以支持链式操作

4. **函数调用运算符**：
   - 创建函数对象
   - 与STL算法结合

5. **下标运算符**：
   - 支持const和非const版本
   - 边界检查

6. **比较运算符**：
   - 实现`==`和`<`，其他可自动生成
   - 用于排序和查找

## 最佳实践

1. ✅ 保持运算符的自然语义
2. ✅ 返回值类型要合理（如赋值返回引用）
3. ✅ `<<`和`>>`重载为非成员函数
4. ✅ 成员函数用于修改左操作数的运算符
5. ✅ 非成员函数用于对称运算符

## 练习

1. ✅ 实现一个复数类，重载所有算术运算符
2. ✅ 为自定义字符串类重载`<<`和`>>`
3. ✅ 实现函数对象用于STL算法
4. ✅ 创建安全的数组类，支持边界检查

---

## 本章总结

第三章"面向对象编程"已全部完成：

1. **类与对象基础**：封装、构造析构、拷贝控制、this指针
2. **类的高级特性**：静态成员、友元、const成员函数
3. **继承与多态**：继承类型、虚函数、抽象类、菱形继承
4. **运算符重载**：重载规则、常用运算符、函数对象

## 下一章
[第四章 内存管理与指针](../第四章-内存管理与指针/README.md) → 学习动态内存管理和智能指针。
