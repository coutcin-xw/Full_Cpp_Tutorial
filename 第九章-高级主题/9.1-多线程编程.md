# 9.1 多线程编程

> C++11引入了多线程支持，使并发编程更加安全和高效

## 目录

- [线程创建与管理](#线程创建与管理)
- [互斥锁与条件变量](#互斥锁与条件变量)
- [原子操作](#原子操作)
- [异步操作（async, future）](#异步操作async-future)
- [本节小结](#本节小结)

---

## 线程创建与管理

### 创建线程

```cpp
#include <thread>
#include <iostream>

void helloFunction() {
    std::cout << "Hello from thread!\n";
}

class HelloTask {
public:
    void operator()() const {
        std::cout << "Hello from functor!\n";
    }

    void method() {
        std::cout << "Hello from method!\n";
    }
};

void creatingThreads() {
    // 1. 使用函数指针
    std::thread t1(helloFunction);
    t1.join();  // 等待线程完成

    // 2. 使用lambda表达式
    std::thread t2([] {
        std::cout << "Hello from lambda!\n";
    });
    t2.join();

    // 3. 使用函数对象
    std::thread t3(HelloTask());
    t3.join();

    // 4. 使用成员函数
    HelloTask task;
    std::thread t4(&HelloTask::method, &task);
    t4.join();

    // 5. 带参数的线程
    void printMessage(const std::string& msg);
    std::thread t5(printMessage, "Hello");
    t5.join();
}
```

### 线程管理

```cpp
void threadManagement() {
    // join：等待线程完成
    {
        std::thread t([] {
            std::cout << "Thread running\n";
        });

        if (t.joinable()) {
            t.join();
        }
    }

    // detach：分离线程，后台运行
    {
        std::thread t([] {
            std::cout << "Detached thread\n";
        });
        t.detach();  // t不再拥有该线程
    } // 线程继续运行

    // join与detach的选择
    std::thread t([] {
        // 长时间运行的任务
    });

    // 如果需要等待结果
    t.join();

    // 如果不需要等待且线程独立运行
    // t.detach();
}
```

### 线程ID与硬件并发

```cpp
#include <thread>

void threadInfo() {
    // 获取线程ID
    std::thread t([] {
        std::cout << "Worker thread ID: "
                  << std::this_thread::get_id() << "\n";
    });

    std::cout << "Main thread ID: "
              << std::this_thread::get_id() << "\n";

    t.join();

    // 硬件并发线程数
    unsigned int n = std::thread::hardware_concurrency();
    std::cout << "Hardware concurrency: " << n << "\n";
}
```

### 线程参数传递

```cpp
#include <string>
#include <memory>

void threadArguments() {
    // 1. 值传递
    void printInt(int x);
    std::thread t1(printInt, 42);

    // 2. 引用传递（使用std::ref）
    void modifyInt(int& x);
    int value = 10;
    std::thread t2(modifyInt, std::ref(value));

    // 3. 移动语义
    void processString(std::string str);
    std::string s = "hello";
    std::thread t3(processString, std::move(s));
    // s现在为空

    // 4. 智能指针
    void handlePtr(std::unique_ptr<int> ptr);
    std::thread t4(handlePtr, std::make_unique<int>(42));

    t1.join();
    t2.join();
    t3.join();
    t4.join();
}
```

### 线程局部存储

```cpp
thread_local int threadLocalVar = 0;

void threadLocalDemo() {
    threadLocalVar = 10;
    std::cout << threadLocalVar << "\n";
}

void tlsExample() {
    std::thread t1(threadLocalDemo);
    std::thread t2(threadLocalDemo);

    t1.join();
    t2.join();

    // 每个线程都有独立的threadLocalVar副本
}
```

---

## 互斥锁与条件变量

### 互斥锁基础

```cpp
#include <mutex>
#include <vector>

std::mutex mtx;
int sharedCounter = 0;

void incrementCounter() {
    // 使用lock_guard自动管理锁
    std::lock_guard<std::mutex> lock(mtx);
    ++sharedCounter;
}

void mutexBasic() {
    std::vector<std::thread> threads;

    // 创建多个线程修改共享变量
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(incrementCounter);
    }

    for (auto& t : threads) {
        t.join();
    }

    std::cout << "Final counter: " << sharedCounter << "\n";
}
```

### unique_lock与lock_guard

```cpp
#include <mutex>

void lockComparison() {
    std::mutex mtx;

    // lock_guard：更轻量，作用域内一直持有锁
    {
        std::lock_guard<std::mutex> lock(mtx);
        // 临界区代码
    }  // 自动释放锁

    // unique_lock：更灵活，可以手动加锁/解锁
    {
        std::unique_lock<std::mutex> lock(mtx);
        // 临界区代码
        lock.unlock();  // 手动解锁
        // 非临界区代码
        lock.lock();   // 重新加锁
    }

    // unique_lock支持条件变量
    std::condition_variable cv;
    std::unique_lock<std::mutex> lock(mtx);
    // cv.wait(lock);  // 需要unique_lock
}
```

### 死锁与避免

```cpp
std::mutex mtx1, mtx2;

// ❌ 可能死锁
void unsafeLock() {
    std::lock(mtx1, mtx2);
    std::lock_guard<std::mutex> lock1(mtx1, std::adopt_lock);
    std::lock_guard<std::mutex> lock2(mtx2, std::adopt_lock);
}

// ✅ 使用std::lock避免死锁
void safeLock() {
    std::lock(mtx1, mtx2);  // 同时锁定两个互斥量
    std::lock_guard<std::mutex> lock1(mtx1, std::adopt_lock);
    std::lock_guard<std::mutex> lock2(mtx2, std::adopt_lock);
}

// ✅ 使用std::scoped_lock（C++17）
void scopedLockDemo() {
    std::scoped_lock lock(mtx1, mtx2);  // RAII风格的std::lock
}

void deadlockPrevention() {
    // 1. 按固定顺序获取锁
    // 2. 使用std::lock同时获取多个锁
    // 3. 使用std::scoped_lock
    // 4. 避免嵌套锁
    // 5. 使用超时锁
}
```

### 递归互斥锁

```cpp
#include <mutex>

class RecursiveData {
private:
    std::recursive_mutex mtx;
    int data;

public:
    void update(int value) {
        std::lock_guard<std::recursive_mutex> lock(mtx);
        data = value;
        innerUpdate();
    }

    void innerUpdate() {
        // 同一线程可以再次获取锁
        std::lock_guard<std::recursive_mutex> lock(mtx);
        data *= 2;
    }
};
```

### 条件变量

```cpp
#include <condition_variable>
#include <queue>

template<typename T>
class ThreadSafeQueue {
private:
    std::queue<T> queue;
    std::mutex mtx;
    std::condition_variable cv;

public:
    void push(T value) {
        std::lock_guard<std::mutex> lock(mtx);
        queue.push(value);
        cv.notify_one();  // 通知一个等待线程
    }

    T pop() {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [this] {
            return !queue.empty();  // 谓词：队列非空
        });

        T value = queue.front();
        queue.pop();
        return value;
    }

    bool tryPop(T& value, int timeoutMs) {
        std::unique_lock<std::mutex> lock(mtx);
        if (cv.wait_for(lock, std::chrono::milliseconds(timeoutMs),
                       [this] { return !queue.empty(); })) {
            value = queue.front();
            queue.pop();
            return true;
        }
        return false;
    }
};

void conditionVariableDemo() {
    ThreadSafeQueue<int> queue;

    // 生产者线程
    std::thread producer([&queue] {
        for (int i = 0; i < 10; ++i) {
            queue.push(i);
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    });

    // 消费者线程
    std::thread consumer([&queue] {
        for (int i = 0; i < 10; ++i) {
            int value = queue.pop();
            std::cout << "Consumed: " << value << "\n";
        }
    });

    producer.join();
    consumer.join();
}
```

---

## 原子操作

### atomic基础

```cpp
#include <atomic>

void atomicBasic() {
    // 原子整数
    std::atomic<int> atomicInt{0};

    // 原子操作
    atomicInt.store(10);           // 写入
    int value = atomicInt.load();  // 读取
    value = atomicInt;             // 隐式load()
    atomicInt = 20;                // 隐式store()

    // 原子增减
    ++atomicInt;                   // 前置++
    atomicInt++;                   // 后置++
    --atomicInt;                   // 前置--
    atomicInt--;                   // 后置--

    // 复合操作
    atomicInt += 5;
    atomicInt -= 3;
    atomicInt |= 0xFF;

    // exchange：原子交换
    int old = atomicInt.exchange(42);

    // compare_exchange_strong：CAS操作
    int expected = 10;
    bool success = atomicInt.compare_exchange_strong(
        expected,  // 期望值
        20         // 新值
    );
    // 如果atomicInt等于expected，设为新值并返回true
    // 否则expected更新为当前值，返回false
}
```

### 原子指针

```cpp
struct Node {
    int data;
    Node* next;
};

void atomicPointer() {
    Node node1{1, nullptr};
    Node node2{2, &node1};

    // 原子指针
    std::atomic<Node*> atomicPtr{&node1};

    // load/store
    Node* ptr = atomicPtr.load();
    atomicPtr.store(&node2);

    // exchange
    Node* old = atomicPtr.exchange(&node1);

    // compare_exchange
    Node* expected = &node1;
    atomicPtr.compare_exchange_strong(expected, &node2);
}
```

### 内存序

```cpp
void memoryOrder() {
    std::atomic<int> x{0};
    std::atomic<int> y{0};

    // 写线程
    std::thread writer([&] {
        x.store(1, std::memory_order_relaxed);
        y.store(1, std::memory_order_release);
    });

    // 读线程
    std::thread reader([&] {
        while (y.load(std::memory_order_acquire) == 0) {
            // 等待
        }
        // 此时必然能看到x = 1
        std::cout << "x = " << x.load(std::memory_order_relaxed) << "\n";
    });

    writer.join();
    reader.join();

    // 内存序类型：
    // memory_order_relaxed：无序
    // memory_order_acquire/acquire：读操作
    // memory_order_release：写操作
    // memory_order_acq_rel：读改写操作
    // memory_order_seq_cst：顺序一致性（默认）
}
```

---

## 异步操作（async, future）

### std::async基础

```cpp
#include <future>
#include <cmath>

int computeSquare(int x) {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    return x * x;
}

void asyncBasic() {
    // 启动异步任务
    std::future<int> result = std::async(std::launch::async, computeSquare, 10);

    // 主线程继续执行
    std::cout << "Computing...\n";

    // 获取结果（阻塞等待）
    int value = result.get();
    std::cout << "Result: " << value << "\n";
}
```

### launch策略

```cpp
void launchPolicies() {
    // async：创建新线程执行
    auto f1 = std::async(std::launch::async, [] {
        return 42;
    });

    // deferred：延迟执行，调用wait()或get()时才执行
    auto f2 = std::async(std::launch::deferred, [] {
        return 42;
    });

    // async | deferred：由实现选择
    auto f3 = std::async(std::launch::async | std::launch::deferred, [] {
        return 42;
    });

    // 默认：async | deferred
    auto f4 = std::async([] {
        return 42;
    });

    int r1 = f1.get();
    int r2 = f2.get();
    int r3 = f3.get();
    int r4 = f4.get();
}
```

### future与shared_future

```cpp
void futureAndSharedFuture() {
    // future：独占所有权
    std::future<int> f = std::async([] {
        return 42;
    });

    int value = f.get();
    // int value2 = f.get();  // 错误：只能调用一次get()

    // shared_future：共享所有权
    std::promise<int> p;
    std::shared_future<int> sf = p.get_future().share();

    // 多个线程可以等待同一个shared_future
    std::thread t1([&sf] {
        int result = sf.get();
        std::cout << "Thread 1: " << result << "\n";
    });

    std::thread t2([&sf] {
        int result = sf.get();
        std::cout << "Thread 2: " << result << "\n";
    });

    p.set_value(42);
    t1.join();
    t2.join();
}
```

### std::promise

```cpp
void promiseDemo() {
    std::promise<int> promise;
    std::future<int> future = promise.get_future();

    std::thread producer([&promise] {
        try {
            // 计算结果
            int result = 42;
            promise.set_value(result);  // 设置结果
        } catch (...) {
            promise.set_exception(std::current_exception());  // 传递异常
        }
    });

    std::thread consumer([&future] {
        try {
            int result = future.get();  // 获取结果
            std::cout << "Result: " << result << "\n";
        } catch (const std::exception& e) {
            std::cout << "Exception: " << e.what() << "\n";
        }
    });

    producer.join();
    consumer.join();
}
```

### std::packaged_task

```cpp
void packagedTaskDemo() {
    // 包装可调用对象
    std::packaged_task<int(int, int)> task([](int a, int b) {
        return a + b;
    });

    std::future<int> result = task.get_future();

    // 在新线程中执行
    std::thread t(std::move(task), 10, 20);

    // 获取结果
    int sum = result.get();
    std::cout << "Sum: " << sum << "\n";

    t.join();
}
```

### 超时等待

```cpp
void timeoutWait() {
    std::promise<int> promise;
    std::future<int> future = promise.get_future();

    // 等待指定时间
    auto status = future.wait_for(std::chrono::seconds(2));

    if (status == std::future_status::ready) {
        std::cout << "Result: " << future.get() << "\n";
    } else if (status == std::future_status::timeout) {
        std::cout << "Timeout\n";
    } else {
        std::cout << "Deferred\n";
    }

    // 等待直到指定时间点
    // future.wait_until(time_point);
}
```

---

## 本节小结

### 知识点回顾

1. **线程管理**：
   - 创建线程：函数、lambda、函数对象
   - join与detach
   - 线程ID和硬件并发

2. **互斥锁**：
   - mutex、lock_guard、unique_lock
   - 死锁避免
   - 条件变量

3. **原子操作**：
   - atomic类型
   - 内存序
   - CAS操作

4. **异步操作**：
   - std::async
   - future与shared_future
   - promise与packaged_task

### 最佳实践

```cpp
// ✅ 推荐做法

// 1. 使用RAII管理锁
std::lock_guard<std::mutex> lock(mtx);

// 2. 最小化临界区
{
    std::lock_guard<std::mutex> lock(mtx);
    // 只在必要时持有锁
}

// 3. 避免数据竞争
std::atomic<int> counter{0};
++counter;  // 原子操作

// 4. 使用条件变量同步
std::unique_lock<std::mutex> lock(mtx);
cv.wait(lock, [] { return ready; });

// ❌ 避免

// 1. 忘记join/detach
std::thread t(func);
// t.join();  // 忘记join导致terminate

// 2. 锁的顺序不一致导致死锁
// 始终按相同顺序获取多个锁

// 3. 过度使用锁
// 考虑使用原子操作

// 4. 忽略异常安全
// 使用RAII确保资源释放
```

### 学习建议

1. **理解并发模型**：共享内存 vs 消息传递
2. **最小化共享状态**：减少同步需求
3. **使用高层抽象**：async、future等
4. **注意性能**：锁竞争、缓存一致性
5. **调试工具**：ThreadSanitizer、Helgrind

### 练习

1. 实现线程安全的队列
2. 使用条件变量实现生产者-消费者模型
3. 编写并行排序算法
4. 对比不同同步机制的性能

---

**下一节：9.2-文件与系统编程** - 系统级编程技巧
