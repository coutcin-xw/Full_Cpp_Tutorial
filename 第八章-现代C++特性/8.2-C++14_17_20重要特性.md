# 8.2 C++14/17/20重要特性

> C++标准持续演进，每个版本都带来强大的新特性

## 目录

- [结构化绑定（C++17）](#结构化绑定c17)
- [if/switch初始化语句（C++17）](#ifswitch初始化语句c17)
- [constexpr扩展（C++14/17/20）](#constexpr扩展c141720)
- [概念Concepts（C++20）](#概念conceptsc20)
- [范围for扩展](#范围for扩展)
- [三路比较运算符（C++20）](#三路比较运算符c20)
- [本节小结](#本节小结)

---

## 结构化绑定（C++17）

结构化绑定允许将数组、结构体或元组解包到多个变量中。

### 基本语法

```cpp
#include <tuple>
#include <map>
#include <string>

void structuredBindingBasic() {
    // 1. 解包数组
    int arr[3] = {1, 2, 3};
    auto [x, y, z] = arr;
    std::cout << x << ", " << y << ", " << z << "\n";

    // 2. 解包结构体
    struct Point {
        double x, y;
    };

    Point p{3.0, 4.0};
    auto [px, py] = p;
    std::cout << "x: " << px << ", y: " << py << "\n";

    // 3. 解包元组
    std::tuple<int, std::string, double> t = std::make_tuple(42, "hello", 3.14);
    auto [id, name, value] = t;
    std::cout << id << ", " << name << ", " << value << "\n";

    // 4. 解包pair（map迭代）
    std::map<std::string, int> map = {{"one", 1}, {"two", 2}};
    for (const auto& [key, val] : map) {
        std::cout << key << " -> " << val << "\n";
    }
}
```

### 引用与const

```cpp
void structuredBindingReference() {
    int arr[2] = {10, 20};

    // 按值绑定（拷贝）
    auto [a1, a2] = arr;
    a1 = 100;
    std::cout << arr[0] << "\n";  // 10（不变）

    // 按引用绑定
    auto& [r1, r2] = arr;
    r1 = 100;
    std::cout << arr[0] << "\n";  // 100（已修改）

    // const引用
    const auto& [cr1, cr2] = arr;
    // cr1 = 200;  // 错误：const

    // 结构体示例
    struct Point {
        int x, y;
    };

    Point p{1, 2};
    auto& [x, y] = p;
    x = 10;  // 修改p.x
    std::cout << p.x << "\n";  // 10
}
```

### 结构化绑定应用场景

```cpp
#include <unordered_map>

void structuredBindingApplications() {
    // 1. 简化多返回值
    auto getPerson() {
        return std::make_tuple("Alice", 30, "Engineer");
    }

    auto [name, age, profession] = getPerson();

    // 2. 遍历map
    std::unordered_map<std::string, int> scores = {
        {"Alice", 90},
        {"Bob", 85}
    };

    for (const auto& [student, score] : scores) {
        std::cout << student << ": " << score << "\n";
    }

    // 3. 访问结构化数据
    struct Employee {
        std::string name;
        int id;
        double salary;
    };

    std::vector<Employee> employees = {
        {"Alice", 1001, 50000.0},
        {"Bob", 1002, 60000.0}
    };

    for (const auto& [e_name, e_id, e_salary] : employees) {
        std::cout << e_id << ": " << e_name << "\n";
    }
}
```

---

## if/switch初始化语句（C++17）

### if初始化语句

```cpp
void ifInitialization() {
    // 传统写法
    std::map<int, std::string> m = {{1, "one"}, {2, "two"}};
    auto it = m.find(1);
    if (it != m.end()) {
        std::cout << it->second << "\n";
    }

    // C++17：if初始化
    if (auto it = m.find(1); it != m.end()) {
        std::cout << it->second << "\n";
    } // it的作用域仅限于if语句

    // 使用结构化绑定
    if (auto [it, success] = m.insert({3, "three"}); success) {
        std::cout << "插入成功\n";
    } else {
        std::cout << "插入失败\n";
    }

    // 锁管理
    std::mutex mtx;
    if (std::lock_guard<std::mutex> lock(mtx); true) {
        // 临界区：lock自动释放
    }

    // 智能指针
    if (auto ptr = std::make_unique<int>(42); ptr != nullptr) {
        std::cout << *ptr << "\n";
    }
}
```

### switch初始化语句

```cpp
void switchInitialization() {
    // 传统写法
    int value;
    std::cin >> value;
    switch (value) {
        case 1:
            // 使用value
            break;
    }

    // C++17：switch初始化
    switch (int x = getValue(); x) {
        case 1:
            std::cout << "一\n";
            break;
        case 2:
            std::cout << "二\n";
            break;
        default:
            std::cout << "其他\n";
    } // x的作用域仅限于switch
}
```

### 实际应用

```cpp
#include <fstream>
#include <vector>

void initializationApplications() {
    // 1. 文件处理
    if (std::ifstream file("data.txt"); file.is_open()) {
        std::string line;
        while (std::getline(file, line)) {
            std::cout << line << "\n";
        }
    } else {
        std::cerr << "文件打开失败\n";
    }

    // 2. 动态分配
    if (auto arr = std::make_unique<int[]>(10); arr != nullptr) {
        // 使用arr
    }

    // 3. 类型转换
    std::string str = "123";
    if (int num; std::istringstream(str) >> num) {
        std::cout << "转换成功: " << num << "\n";
    }

    // 4. 组合条件
    std::map<std::string, int> ages = {{"Alice", 30}, {"Bob", 25}};
    if (auto it = ages.find("Alice"); it != ages.end() && it->second > 20) {
        std::cout << it->first << "年龄大于20\n";
    }
}
```

---

## constexpr扩展（C++14/17/20）

### C++14：更宽松的constexpr

```cpp
// C++11：constexpr函数限制很多
constexpr int factorialC11(int n) {
    return n <= 1 ? 1 : n * factorialC11(n - 1);
}

// C++14：允许局部变量、循环、条件语句
constexpr int factorialC14(int n) {
    int result = 1;
    for (int i = 2; i <= n; ++i) {
        result *= i;
    }
    return result;
}

void constexprC14() {
    // 编译期计算
    constexpr int f5 = factorialC14(5);  // 120

    // 运行期计算
    int n;
    std::cin >> n;
    int result = factorialC14(n);
}
```

### constexpr函数增强

```cpp
// C++14：更复杂的constexpr函数
constexpr bool isPrime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

void constexprEnhancements() {
    // 编译期判断
    static_assert(isPrime(7), "7是素数");

    // 运行期判断
    int n = 11;
    bool prime = isPrime(n);

    // constexpr变量
    constexpr int max = 100;
    constexpr bool check = isPrime(max);
}
```

### C++17：if constexpr

```cpp
template<typename T>
constexpr auto get_value(T t) {
    if constexpr (std::is_pointer_v<T>) {
        return *t;  // 如果T是指针类型
    } else {
        return t;   // 否则
    }
}

void ifConstexpr() {
    int x = 42;
    int* ptr = &x;

    auto val1 = get_value(x);   // 42
    auto val2 = get_value(ptr); // 42

    // 编译期分支选择
    template<typename T>
    void process(T t) {
        if constexpr (std::is_integral_v<T>) {
            std::cout << "整数类型\n";
        } else if constexpr (std::is_floating_point_v<T>) {
            std::cout << "浮点类型\n";
        } else {
            std::cout << "其他类型\n";
        }
    }

    process(42);      // 整数类型
    process(3.14);    // 浮点类型
    process("hello"); // 其他类型
}
```

---

## 概念Concepts（C++20）

概念（Concepts）为模板参数指定约束，使模板代码更清晰。

### 基本语法

```cpp
#include <concepts>
#include <type_traits>

// 定义概念
template<typename T>
concept Integral = std::is_integral_v<T>;

template<typename T>
concept Addable = requires(T a, T b) {
    a + b;  // 必须支持+运算符
};

// 使用概念约束模板
template<Integral T>
T add(T a, T b) {
    return a + b;
}

void conceptsBasic() {
    add(1, 2);      // OK：int是整数类型
    // add(1.0, 2.0); // 错误：double不满足Integral概念

    // requires子句
    template<typename T>
    requires Integral<T>
    T multiply(T a, T b) {
        return a * b;
    }

    // 简写语法
    template<std::integral T>
    T divide(T a, T b) {
        return a / b;
    }
}
```

### 自定义概念

```cpp
// 数值概念
template<typename T>
concept Numeric = std::integral<T> || std::floating_point<T>;

// 可排序概念
template<typename T>
concept Sortable = requires(T a, T b) {
    a < b;
    a > b;
};

// 容器概念
template<typename T>
concept Container = requires(T t) {
    typename T::value_type;
    { t.size() } -> std::convertible_to<std::size_t>;
    { t.begin() } -> std::input_iterator;
};

void customConcepts() {
    // 使用自定义概念
    template<Numeric T>
    T square(T x) {
        return x * x;
    }

    square(5);      // OK
    square(3.14);   // OK
    // square("hello"); // 错误
}
```

---

## 范围for扩展

### 基于范围的for循环增强

```cpp
void rangeForEnhancements() {
    // 1. 初始化语句（C++20）
    std::map<int, std::string> m = {{1, "one"}, {2, "two"}};

    for (auto it = m.begin(); auto& [key, value] : *it; ++it) {
        // C++20的扩展（某些编译器支持）
        std::cout << key << ": " << value << "\n";
    }

    // 2. 更灵活的begin/end
    struct MyRange {
        int* data;
        size_t size;

        int* begin() { return data; }
        int* end() { return data + size; }
    };

    MyRange range{new int[3]{1, 2, 3}, 3};
    for (int val : range) {
        std::cout << val << " ";
    }
    delete[] range.data;
}
```

---

## 三路比较运算符（C++20）

### 基本语法

```cpp
#include <compare>

struct Point {
    int x, y;

    // 自动生成所有比较运算符
    auto operator<=>(const Point&) const = default;
};

void threeWayComparison() {
    Point p1{1, 2};
    Point p2{1, 2};
    Point p3{2, 3};

    std::cout << (p1 == p2) << "\n";  // true
    std::cout << (p1 < p3) << "\n";    // true
    std::cout << (p1 <= p2) << "\n";   // true
}
```

### 自定义三路比较

```cpp
struct Version {
    int major, minor, patch;

    auto operator<=>(const Version&) const = default;
};

void customThreeWay() {
    Version v1{1, 2, 3};
    Version v2{1, 2, 4};

    std::cout << (v1 < v2) << "\n";  // true
    std::cout << (v1 == v2) << "\n"; // false
}
```

### 比较类别

```cpp
void comparisonCategories() {
    // 三路比较的结果类型
    auto result = (1 <=> 2);

    if (result < 0) {
        std::cout << "小于\n";
    } else if (result > 0) {
        std::cout << "大于\n";
    } else {
        std::cout << "等于\n";
    }

    // strong_ordering：完全有序
    std::strong_ordering strong = (1 <=> 2);

    // partial_ordering：部分有序（如浮点数NaN）
    std::partial_ordering partial = (1.0 <=> 2.0);

    // weak_ordering：弱有序（如忽略大小写的字符串）
    std::weak_ordering weak = (std::string("a") <=> std::string("b"));
}
```

---

## 本节小结

### 知识点回顾

1. **结构化绑定**：
   - 解包数组、结构体、元组
   - 支持引用和const
   - 简化多返回值处理

2. **if/switch初始化**：
   - 限制变量作用域
   - 简化资源管理
   - 提高代码可读性

3. **constexpr扩展**：
   - C++14：更宽松的限制
   - C++17：if constexpr
   - 编译期计算增强

4. **概念Concepts**：
   - 约束模板参数
   - 清晰的错误信息
   - requires表达式

5. **范围for扩展**：
   - 更灵活的begin/end
   - 初始化语句

6. **三路比较运算符**：
   - 自动生成比较运算符
   - 比较类别
   - 简化类定义

### 最佳实践

```cpp
// ✅ 推荐做法

// 1. 使用结构化绑定简化代码
for (const auto& [key, value] : map) {
    // 处理键值对
}

// 2. 使用if初始化限制作用域
if (auto it = map.find(key); it != map.end()) {
    // 使用it
}

// 3. 使用概念约束模板
template<std::integral T>
void process(T value);

// 4. 使用default比较运算符
auto operator<=>(const MyClass&) const = default;

// 5. 使用if constexpr替代SFINAE
template<typename T>
void func() {
    if constexpr (std::is_integral_v<T>) {
        // 整数版本
    }
}

// ❌ 避免

// 1. 过度使用新特性降低兼容性
// 如果代码需要在旧编译器运行

// 2. 概念定义过于复杂
// 保持概念简单明了

// 3. 滥用结构化绑定
// auto [x, y] = getValues();
// // x和y的含义不明确
```

### 版本特性速查

| 特性 | C++14 | C++17 | C++20 |
|------|-------|-------|-------|
| 结构化绑定 | | ✅ | |
| if/switch初始化 | | ✅ | |
| if constexpr | | ✅ | |
| constexpr扩展 | ✅ | ✅ | ✅ |
| 概念Concepts | | | ✅ |
| 三路比较 | | | ✅ |
| 范围for扩展 | | | ✅ |

### 学习建议

1. **渐进学习**：从C++11到C++20逐步掌握
2. **关注实际需求**：不需要过度使用所有新特性
3. **兼容性考虑**：注意编译器支持情况
4. **代码可读性**：新特性应提高而非降低可读性
5. **实践应用**：在实际项目中使用新特性

### 练习

1. 使用结构化绑定简化多返回值处理
2. 编写模板函数，使用概念约束参数类型
3. 使用if constexpr替代类型萃取的SFINAE技巧
4. 为自定义类实现三路比较运算符

---

**第八章完成！下一章：高级主题**
