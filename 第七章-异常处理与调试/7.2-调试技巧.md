# 7.2 调试技巧

> 高效定位和修复程序错误的艺术

## 目录

- [断言（assert）](#断言assert)
- [调试器使用基础](#调试器使用基础)
- [日志记录](#日志记录)
- [本节小结](#本节小结)

---

## 断言（assert）

断言（Assertion）是一种在程序运行时检查条件的机制，用于验证程序中的假设是否成立。断言失败意味着程序存在逻辑错误。

### assert基础

C++标准库提供了`<cassert>`头文件，包含`assert`宏。

```cpp
#include <cassert>
#include <cmath>

void assertBasic() {
    int x = 5;

    // 正常断言：条件为真时继续执行
    assert(x > 0);

    // 断言失败会终止程序并显示错误信息
    // assert(x == 10);  // 如果x != 10，程序终止

    // 带有表达式的断言
    assert(sqrt(16.0) == 4.0);
}
```

### assert的应用场景

```cpp
#include <vector>
#include <string>

void assertScenarios() {
    // 1. 检查函数前置条件
    int divide(int a, int b) {
        assert(b != 0 && "除数不能为零");
        return a / b;
    }

    // 2. 检查数组边界
    void processArray(const std::vector<int>& arr, size_t index) {
        assert(index < arr.size() && "索引越界");
        // 处理arr[index]
    }

    // 3. 检查不变量
    void sortArray(std::vector<int>& arr) {
        // 排序前
        bool isSorted = true;
        // ... 排序逻辑 ...
        for (size_t i = 1; i < arr.size(); ++i) {
            if (arr[i-1] > arr[i]) {
                isSorted = false;
                break;
            }
        }
        assert(isSorted && "数组排序失败");
    }

    // 4. 检查指针有效性
    void processData(int* ptr) {
        assert(ptr != nullptr && "空指针");
        *ptr = 42;
    }
}
```

### static_assert（编译时断言）

C++11引入的`static_assert`在编译时检查条件，不会产生运行时开销。

```cpp
void staticAssertDemo() {
    // 编译时检查类型大小
    static_assert(sizeof(int) >= 4, "int至少4字节");

    // 编译时检查模板参数
    template<typename T>
    void process() {
        static_assert(std::is_integral<T>::value,
                      "T必须是整数类型");
    }

    process<int>();   // OK
    // process<double>(); // 编译错误

    // 检查枚举值
    enum Color { Red, Green, Blue };
    static_assert(Red == 0, "Red必须为0");
}
```

### 自定义断言宏

```cpp
// 自定义断言宏，带有错误消息
#define VERIFY(condition, message) \
    do { \
        if (!(condition)) { \
            std::cerr << "断言失败: " << message \
                      << "\n文件: " << __FILE__ \
                      << "\n行: " << __LINE__ \
                      << "\n函数: " << __FUNCTION__ << "\n"; \
            std::abort(); \
        } \
    } while(0)

void customAssert() {
    int x = 5;
    VERIFY(x > 10, "x必须大于10");
}
```

### 断言使用原则

```cpp
// ✅ 推荐做法

// 1. 检查不可能发生的条件
void processData(int* ptr) {
    assert(ptr != nullptr);  // 永远不应该传入空指针
}

// 2. 检查函数前置条件
void setArrayValue(int* arr, size_t size, size_t index, int value) {
    assert(index < size);  // 确保索引有效
    arr[index] = value;
}

// 3. 检查类不变量
class MyClass {
    int value;
public:
    void setValue(int v) {
        assert(v >= 0 && "值必须非负");
        value = v;
        assert(value >= 0);  // 不变量检查
    }
};

// ❌ 避免

// 1. 不要用断言检查用户输入
// assert(userInput > 0);  // 错误：用户输入可能无效
if (userInput <= 0) {
    // 处理错误情况
}

// 2. 不要用断言检查可恢复的错误
// assert(file.open());  // 错误：文件打开失败应处理
if (!file.open()) {
    // 处理文件打开失败
}

// 3. 避免有副作用的断言
// assert(i++ < 10);  // 错误：Release版本中i不会递增
```

### NDEBUG宏

定义`NDEBUG`宏可以禁用所有`assert`检查，通常用于Release版本。

```cpp
// 编译时定义NDEBUG禁用断言
// g++ -DNDEBUG -O2 program.cpp

void assertWithNDEBUG() {
    #ifdef NDEBUG
        std::cout << "断言已禁用\n";
    #else
        std::cout << "断言已启用\n";
    #endif

    int x = 5;
    assert(x == 10);  // Release版本中不会执行

    // 使用条件代码确保重要检查始终执行
    if (x != 10) {
        std::cerr << "严重错误\n";
        std::abort();
    }
}
```

---

## 调试器使用基础

调试器（Debugger）是查找和修复程序错误的重要工具。最常用的是GDB（GNU Debugger）。

### GDB基础命令

```bash
# 编译程序时添加调试信息
g++ -g program.cpp -o program

# 启动GDB
gdb ./program

# GDB常用命令
(gdb) run               # 运行程序
(gdb) break main        # 在main函数设置断点
(gdb) break 15          # 在第15行设置断点
(gdb) break MyClass::myFunction  # 在成员函数设置断点
(gdb) continue          # 继续执行
(gdb) next              # 单步执行（不进入函数）
(gdb) step              # 单步执行（进入函数）
(gdb) print variable    # 打印变量值
(gdb) display variable  # 每次停止时显示变量
(gdb) backtrace         # 查看调用栈
(gdb) frame 0           # 切换到栈帧0
(gdb) info locals       # 查看局部变量
(gdb) quit              # 退出GDB
```

### GDB调试示例

```cpp
// debug_example.cpp
#include <iostream>
#include <vector>

int add(int a, int b) {
    int result = a + b;
    return result;  // 设置断点
}

double average(const std::vector<int>& numbers) {
    if (numbers.empty()) {
        return 0.0;
    }

    double sum = 0.0;
    for (size_t i = 0; i < numbers.size(); ++i) {
        sum += numbers[i];  // 设置断点
    }
    return sum / numbers.size();
}

int main() {
    int x = 10;
    int y = 20;
    int z = add(x, y);  // 设置断点

    std::vector<int> nums = {1, 2, 3, 4, 5};
    double avg = average(nums);

    std::cout << "Sum: " << z << "\n";
    std::cout << "Average: " << avg << "\n";

    return 0;
}
```

调试会话示例：

```bash
$ g++ -g debug_example.cpp -o debug_example
$ gdb ./debug_example
(gdb) break main
Breakpoint 1 at 0x...: file debug_example.cpp, line 26.
(gdb) run

Breakpoint 1, main () at debug_example.cpp:26
26          int x = 10;
(gdb) next
27          int y = 20;
(gdb) print x
$1 = 10
(gdb) break add
Breakpoint 2 at 0x...: file debug_example.cpp, line 5.
(gdb) continue

Breakpoint 2, add (a=10, b=20) at debug_example.cpp:5
5           int result = a + b;
(gdb) print a
$2 = 10
(gdb) print b
$3 = 20
(gdb) step
6           return result;
(gdb) print result
$4 = 30
(gdb) backtrace
#0  add (a=10, b=20) at debug_example.cpp:6
#1  0x... in main () at debug_example.cpp:30
(gdb) continue
Continuing.
Sum: 30
Average: 3
[Inferior 1 (process 12345) exited normally]
(gdb) quit
```

### 条件断点

```bash
# 只在特定条件时触发断点
(gdb) break 15 if i == 5

# 当变量值改变时触发
(gdb) watch variable_name

# 只在变量被读取时触发
(gdb) rwatch variable_name

# 只在变量被写入时触发
(gdb) awatch variable_name
```

### GDB高级技巧

```bash
# 查看调用栈
(gdb) backtrace
# 或
(gdb) bt

# 切换栈帧
(gdb) frame 2
(gdb) up        # 上移一帧
(gdb) down      # 下移一帧

# 查看线程信息
(gdb) info threads

# 切换线程
(gdb) thread 2

# 查看汇编代码
(gdb) disassemble

# 查看寄存器
(gdb) info registers

# 修改变量值
(gdb) set variable x = 42

# 调用函数
(gdb) call myFunction()

# 设置断点命令列表
(gdb) commands
> print x
> print y
> continue
> end

# 保存断点
(gdb) save breakpoints my_gdb_breakpoints

# 加载断点
(gdb) source my_gdb_breakpoints
```

### IDE调试器

现代IDE（如Visual Studio, CLion, VS Code）提供图形化调试界面：

```cpp
// 常用IDE调试功能：
// 1. 点击行号设置断点
// 2. 查看变量值（鼠标悬停）
// 3. 监视窗口（Watch Window）
// 4. 调用栈窗口（Call Stack）
// 5. 内存窗口（Memory Window）
// 6. 条件断点（右键断点设置条件）
// 7. 数据断点（Data Breakpoint）
```

### 常见调试策略

```cpp
// 1. 二分法定位错误
void binarySearchDebug() {
    // 注释掉一半代码
    // 如果错误仍存在，错误在剩余代码中
    // 如果错误消失，错误在被注释的代码中
}

// 2. 最小化复现
void minimalReproduction() {
    // 移除不相关的代码
    // 创建最小的复现用例
}

// 3. 添加调试输出
void debugOutput() {
    std::cerr << "Debug: Reached point A\n";

    // 可疑代码

    std::cerr << "Debug: Reached point B\n";
}

// 4. 使用调试宏
#ifdef DEBUG
    #define DEBUG_PRINT(x) std::cerr << x << "\n"
#else
    #define DEBUG_PRINT(x)
#endif

void functionWithDebug() {
    DEBUG_PRINT("Enter function");
    // 函数逻辑
    DEBUG_PRINT("Exit function");
}
```

---

## 日志记录

日志（Logging）是记录程序运行时信息的重要手段，有助于问题追踪和性能分析。

### 简单日志系统

```cpp
#include <iostream>
#include <fstream>
#include <chrono>
#include <iomanip>
#include <sstream>

enum class LogLevel {
    DEBUG,
    INFO,
    WARNING,
    ERROR
};

class Logger {
private:
    std::ofstream logFile;
    LogLevel minLevel;
    bool consoleOutput;

    std::string getTimestamp() {
        auto now = std::chrono::system_clock::now();
        auto time = std::chrono::system_clock::to_time_t(now);
        std::stringstream ss;
        ss << std::put_time(std::localtime(&time), "%Y-%m-%d %H:%M:%S");
        return ss.str();
    }

    std::string levelToString(LogLevel level) {
        switch (level) {
            case LogLevel::DEBUG:   return "DEBUG";
            case LogLevel::INFO:    return "INFO";
            case LogLevel::WARNING: return "WARNING";
            case LogLevel::ERROR:   return "ERROR";
            default:                return "UNKNOWN";
        }
    }

public:
    Logger(const std::string& filename,
           LogLevel minLevel = LogLevel::INFO,
           bool console = true)
        : minLevel(minLevel), consoleOutput(console) {
        logFile.open(filename, std::ios::app);
    }

    ~Logger() {
        logFile.close();
    }

    void log(LogLevel level, const std::string& message) {
        if (level < minLevel) return;

        std::string logMessage = "[" + getTimestamp() + "] "
                                + "[" + levelToString(level) + "] "
                                + message;

        if (logFile.is_open()) {
            logFile << logMessage << "\n";
            logFile.flush();
        }

        if (consoleOutput) {
            if (level >= LogLevel::ERROR) {
                std::cerr << logMessage << "\n";
            } else {
                std::cout << logMessage << "\n";
            }
        }
    }

    void debug(const std::string& message) {
        log(LogLevel::DEBUG, message);
    }

    void info(const std::string& message) {
        log(LogLevel::INFO, message);
    }

    void warning(const std::string& message) {
        log(LogLevel::WARNING, message);
    }

    void error(const std::string& message) {
        log(LogLevel::ERROR, message);
    }
};

// 使用示例
void loggingDemo() {
    Logger logger("app.log", LogLevel::DEBUG);

    logger.debug("调试信息");
    logger.info("程序启动");
    logger.warning("配置文件未找到，使用默认配置");
    logger.error("无法连接数据库");

    // 使用宏简化日志记录
    #define LOG_DEBUG(logger, msg) logger.debug(msg)
    #define LOG_INFO(logger, msg) logger.info(msg)
    #define LOG_WARNING(logger, msg) logger.warning(msg)
    #define LOG_ERROR(logger, msg) logger.error(msg)

    LOG_INFO(logger, "用户登录成功");
}
```

### 结构化日志

```cpp
#include <map>
#include <variant>

struct LogEntry {
    std::string timestamp;
    LogLevel level;
    std::string message;
    std::map<std::string, std::string> context;
};

class StructuredLogger {
private:
    Logger logger;

public:
    StructuredLogger(const std::string& filename)
        : logger(filename, LogLevel::INFO) {}

    void log(const LogEntry& entry) {
        std::string fullMessage = entry.message;

        if (!entry.context.empty()) {
            fullMessage += " | ";
            for (const auto& [key, value] : entry.context) {
                fullMessage += key + "=" + value + " ";
            }
        }

        logger.log(entry.level, fullMessage);
    }
};

void structuredLoggingDemo() {
    StructuredLogger slogger("structured.log");

    LogEntry entry;
    entry.level = LogLevel::INFO;
    entry.message = "HTTP请求";
    entry.context["method"] = "GET";
    entry.context["path"] = "/api/users";
    entry.context["status"] = "200";
    entry.context["duration_ms"] = "45";

    slogger.log(entry);
    // 输出：[2024-01-15 10:30:45] [INFO] HTTP请求 | method=GET path=/api/users status=200 duration_ms=45
}
```

### 性能日志

```cpp
#include <chrono>

class PerformanceLogger {
private:
    std::string operationName;
    std::chrono::high_resolution_clock::time_point start;
    StructuredLogger& logger;

public:
    PerformanceLogger(const std::string& name, StructuredLogger& log)
        : operationName(name), logger(log) {
        start = std::chrono::high_resolution_clock::now();
    }

    ~PerformanceLogger() {
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

        LogEntry entry;
        entry.level = LogLevel::INFO;
        entry.message = "性能统计";
        entry.context["operation"] = operationName;
        entry.context["duration_ms"] = std::to_string(duration.count());

        logger.log(entry);
    }
};

void performanceLoggingDemo() {
    StructuredLogger slogger("performance.log");

    {
        PerformanceLogger pl("数据库查询", slogger);
        // 执行数据库查询
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }  // 自动记录执行时间

    // 输出：[2024-01-15 10:30:45] [INFO] 性能统计 | operation=数据库查询 duration_ms=100
}
```

### 日志最佳实践

```cpp
// ✅ 推荐做法

// 1. 使用合适的日志级别
logger.debug("详细调试信息");       // 开发调试
logger.info("正常流程信息");         // 重要事件
logger.warning("警告但可继续");      // 潜在问题
logger.error("错误但可恢复");        // 错误情况

// 2. 记录足够的上下文
void processUser(int userId, const std::string& action) {
    logger.info("用户操作: userId=" + std::to_string(userId) +
                ", action=" + action);
}

// 3. 使用结构化日志
LogEntry entry;
entry.context["user_id"] = std::to_string(userId);
entry.context["action"] = action;
entry.context["timestamp"] = getCurrentTimestamp();

// 4. 避免日志泄漏敏感信息
// logger.info("密码: " + password);  // ❌ 错误
logger.info("用户登录: userId=" + std::to_string(userId));  // ✅ 正确

// 5. 使用条件日志减少开销
#ifdef DEBUG
    logger.debug("调试信息: " + expensiveOperation());
#endif

// 6. 异步日志避免阻塞
// 生产环境应使用异步日志库（如spdlog, glog）

// ❌ 避免

// 1. 过度日志
for (int i = 0; i < 1000000; ++i) {
    logger.debug("循环计数: " + std::to_string(i));  // 性能问题
}

// 2. 日志中包含复杂计算
logger.debug("结果: " + std::to_string(complexFunction()));  // 即使不输出也会计算

// 3. 混合不同日志级别
logger.info("错误信息");  // 应使用error级别
```

### 常用日志库

```cpp
// 1. spdlog（推荐）
// #include <spdlog/spdlog.h>
// spdlog::info("Hello, {}!", "World");

// 2. glog（Google Logging Library）
// #include <glog/logging.h>
// LOG(INFO) << "Hello, World!";

// 3. Boost.Log
// #include <boost/log/trivial.hpp>
// BOOST_LOG_TRIVIAL(info) << "Hello, World!";

// 4. easyloggingpp
// #include <easylogging++.h>
// LOG(INFO) << "Hello, World!";
```

---

## 本节小结

### 知识点回顾

1. **断言**：
   - assert运行时检查
   - static_assert编译时检查
   - NDEBUG宏控制

2. **调试器**：
   - GDB基础命令
   - 断点、单步、查看变量
   - 条件断点和数据断点

3. **日志记录**：
   - 日志级别
   - 结构化日志
   - 性能日志

### 最佳实践

```cpp
// ✅ 推荐做法

// 1. 断言用于检查不可能发生的条件
assert(ptr != nullptr && "空指针");

// 2. 日志记录重要事件
logger.info("程序启动");
logger.error("数据库连接失败");

// 3. 使用调试器逐步跟踪
(gdb) break可疑位置
(gdb) step单步执行
(gdb) print变量值

// ❌ 避免

// 1. 断言检查用户输入
// assert(userInput > 0);  // 错误

// 2. 过度日志
// for (int i = 0; i < 1000000; ++i) {
//     logger.debug(std::to_string(i));  // 性能问题
// }

// 3. 忽略编译警告
// 警告往往暗示潜在问题
```

### 学习建议

1. **善用断言**：在开发阶段大量使用，Release版本禁用
2. **学习调试器**：掌握GDB或IDE调试器的基本操作
3. **建立日志系统**：为项目配置合适的日志库
4. **代码审查**：通过review发现潜在问题
5. **单元测试**：预防bug产生

### 调试工具推荐

1. **Valgrind**：内存泄漏检测
2. **AddressSanitizer**：内存错误检测
3. **静态分析**：clang-tidy, cppcheck
4. **动态分析**：perf, gprof
5. **日志库**：spdlog, glog

### 练习

1. 编写一个程序，使用assert验证数组操作的边界
2. 使用GDB调试包含递归函数的程序
3. 实现一个简单的日志系统，支持多级别输出
4. 使用Valgrind检测内存泄漏

---

**第七章完成！下一章：现代C++特性**
